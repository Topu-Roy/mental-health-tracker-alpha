The application prompts the user at the end of each day with a guided review of their experience, asking for an overall assessment of the day, their general mood, the specific emotions they felt, and a tally of how many times each emotion was triggered. Throughout the day, the user can freely enter an unlimited number of journal entries. Once the daily reflection is complete, the application calculates their overall performance and provides various metrics. Finally, as part of the end-of-day process, the user is required to write journal entries detailing what they learned that day and the lessons they gathered.


model User {
  id            String    @id @default(uuid())
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  role          String?
  banned        Boolean?  @default(false)
  banReason     String?
  banExpires    DateTime?
  sessions      Session[]
  accounts      Account[]
  passkeys      Passkey[]

  @@unique([email])
  @@map("user")
}

model Session {
  id             String   @id @default(uuid())
  expiresAt      DateTime
  token          String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  ipAddress      String?
  userAgent      String?
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy String?

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Passkey {
  id           String   @id
  name         String?
  publicKey    String
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  aaguid       String?

  @@index([userId])
  @@index([credentialID])
  @@map("passkey")
}
